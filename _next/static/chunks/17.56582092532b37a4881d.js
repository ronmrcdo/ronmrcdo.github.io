(window.webpackJsonp_N_E=window.webpackJsonp_N_E||[]).push([[17],{q3qe:function(t,n,e){"use strict";e.r(n),n.default="---\ntitle: \"Part 1 - Angular Authentication with NGXS and JWT\"\ndescription: \"Managing Authentication for Angular with JWT.\"\ndate: \"2020-10-01\"\nkeywords: \"Angular,NGXS,Authentication,State Management\"\n---\n\nState management is a method of managing the state of the application (front end). **NGXS** is a state management pattern and library for Angular.\n\n### What is  **NGXS**\n\n> NGXS is a state management pattern + library. It provides as a single\n> source of truth for your application's state, providing simple rules\n> for predictable state mutations.\n> \n> NGXS is modeled after the CQRS pattern popularly implemented in\n> libraries like Redux and NgRx but reduces boilerplate by using modern\n> TypeScript features such as classes and decorators.\n\n### Introduction\nIn this article we will cover the auth state, auth service and dependencies.\n\n### Getting Started\n**1. Install packages and import to app.module.ts**\n\nUsing npm\n    \n    npm install @ngxs/store @ngxs/storage-plugin @ngxs/router-plugin @auth0/angular-jwt\n\nUsing yarn\n\n    yarn add @ngxs/store @ngxs/storage-plugin @ngxs/router-plugin @auth0/angular-jwt\n\nCreate a **store** folder in your src. This fille will automatically import your states, persistent keys to the app.module.ts\n\n    // src/_store/index.ts\n    import { AuthState } from './auth';\n    \n    export * from './auth';\n    \n    export const AppState = [\n     AuthState\n    ];\n    \n    export const PersistAppState = {\n\t  key: [\n\t    'auth.token',\n      ]\n    };\n\nImport the dependencies on the app.module.ts\n\n    // src/app/app.module.ts\n    import { NgModule } from '@angular/core';\n    \n    /**\n     * State\n     */\n    import { NgxsModule } from '@ngxs/store';\n    import { NgxsRouterPluginModule } from '@ngxs/router-plugin';\n    import { NgxsStoragePluginModule } from '@ngxs/storage-plugin';\n    import { environment as env } from '../environments/environment';\n    import { AppState, PersistAppState } from './_store';\n    \n    @NgModule({\n      //..\n      imports: [\n       NgxsModule.forRoot(\n         AppState,\n         { developmentMode: !env.production }\n       ),\n       NgxsRouterPluginModule.forRoot(),\n       NgxsStoragePluginModule.forRoot(PersistAppState),\n       //..\n      ],\n      //..\n    })\n    export class AppModule {}\n**2. Creating the Auth Service**\nFirst we need to create our auth service. This will communicate directly to the server using http client. Inside src folder create the **services** folder and the **auth.service.ts**.\n\n    mkdir _services && touch _services/auth.service.ts\n\nInside the auth.service \n\n    // src/_services/auth.service.ts\n    import { Injectable } from '@angular/core';\n    import { HttpClient } from '@angular/common/http';\n    import { Observable } from 'rxjs';\n    import { JwtHelperService } from '@auth0/angular-jwt';\n    import { environment as env } from '../../environments/environment';\n    \n    @Injectable({ providedIn: 'root' })\n    export class AuthService {\n    \n        private _jwtService: JwtHelperService;\n        private readonly baseUrl: string = env.API_URL;\n    \n        constructor(private _httpClient: HttpClient) {\n            this._jwtService = new JwtHelperService();\n        }\n    \n        isExpired(token: string): boolean {\n            try {\n                return this._jwtService.isTokenExpired(token);\n            } catch (err) {\n                return false;\n            }\n        }\n    \n        login(credentials: { email: string, password: string }): Observable<any> {\n            return this._httpClient.post(`${this.baseUrl}/login`, credentials);\n        }\n    \n        logout(): Observable<any> {\n            return this._httpClient.post(`${this.baseUrl}/logout`);\n        }\n    }\n\n**3. Creating the State**\nInside your **src/_store** folder, Create another folder name **auth** \n\n    mkdir auth\n\nAfter creating the folder, create the necessary file.\n\n    touch auth.state.ts && touch auth.actions.ts && touch index.ts\n\nDefining State and Actions.\n\n> An **action** is a type of command which should be called when\n> something happens or you want to trigger at an event\n> \n> **States** are classes along with decorators to describe metadata and\n> action mappings.\n\n    // src/_store/auth/auth.actions.ts\n    export class AuthStateModel {\n      isAuthenticated: boolean;\n      token: string | null;\n    }\n    \n    export class CheckSession {\n      static readonly type = '[Auth] CheckSession';\n    }\n    \n    export class Login {\n      static readonly type = '[Auth] Login';\n      constructor(public credentials: { email: string, password: string}) { }\n    }\n    \n    export class Logout {\n      static readonly type = '[Auth] Logout';\n    }\n    \n    export class LoginSuccess {\n      static readonly type = '[Auth] LoginSuccess';\n      constructor(public token: string) { }\n    }\n    \n    export class LoginRedirect {\n      static readonly type = '[Auth] LoginRedirect';\n    }\n    \n    export type AuthActions =\n      | CheckSession\n      | Login\n      | Logout\n      | LoginSuccess\n      | LoginRedirect;\n    \n    export const AuthDefaultState = {\n      isAuthenticated: false,\n      token: null;\n    };\nAfter creating the actions. Create now the state it will contain the global state of auth.\n\n    // src/_store/auth/auth.state.ts\n    import { Injectable } from '@angular/core';\n    import { State, Selector, StateContext, Action, NgxsOnInit } from '@ngxs/store';\n    import { Navigate } from '@ngxs/router-plugin';\n    import { Observable, throwError } from 'rxjs';\n    import { tap, catchError } from 'rxjs/operators';\n    \n    import { AuthService } from '../../_services/auth.service';\n    import {\n      AuthStateModel,\n      AuthDefaultState,\n      CheckSession,\n      Login,\n      Logout\n      LoginSuccess,\n      LoginRedirect\n    } from './auth.actions';\n    \n    interface ITokenResponse {\n        access_token: string;\n        token_type: string;\n        expires_in: number;\n        refresh_token: string;\n    }\n    \n    @State<AuthStateModel>({\n        name: 'auth',\n        defaults: AuthDefaultState\n    })\n    @Injectable({ providedIn: 'root' }) // For specific version of angular you need to include this to make it work\n    export class AuthState implements NgxsOnInit {\n    \n        protected readonly fallBackUrl = '/dashboard';\n        protected readonly loginUrl = '/login';\n    \n        constructor(private _authService: AuthService) { }\n    \n        @Selector()\n        static token(state: AuthStateModel): string|null {\n            return state.token;\n        }\n    \n        @Selector()\n        static isAuthenticated(state: AuthStateModel): boolean {\n            return state.isAUthenticated;\n        }\n    \n        // This will trigger to check the token if it's still valid\n        ngxsOnInit({ dispatch }: StateContext<AuthStateModel>): void {\n            dispatch(new CheckSession());\n        }\n    \n        @Action(CheckSession)\n        validateSession({ dispatch, getState }: StateContext<AuthStateModel>): void {\n            const { token } = getState();\n    \n            if (token && !this._authService.isExpired(token)) {\n                dispatch(new LoginSuccess(token));\n            } else {\n                dispatch(new LoginRedirect());\n            }\n        }\n    \n        @Action(Login)\n        authenticateUser({ dispatch }: StateContext<AuthStateModel>, { credentials }): Observable<any> {\n            return this._authService.login(credentials)\n                .pipe(\n                    tap(({ acess_token, refresh_token }: ITokenResponse) => {\n                        dispatch(new LoginSuccess(access_token));\n                    })\n                );\n        }\n    \n        @Action(Logout)\n        logout({ dispatch }: StateContext<AuthStateModel>): Observable<any> {\n            return this._authService.logout()\n                .pipe(\n                    tap(_ => dispatch(new LoginRedirect())),\n                    catchError((err: any) => dispatch(new LoginRedirect()))\n                );\n        }\n    \n        @Action(LoginSuccess)\n        onLoginSuccess({ patchState: dispatch }: StateContext<AuthStateModel>, { token }: LoginSuccess): void {\n            patchState({\n                isAuthenticated: true,\n                token\n            });\n    \n            dispatch(new Navigate([this.fallBackUrl]));\n        }\n    \n        @Action(LoginRedirect)\n        onRedirection({ patchState, dispatch }: StateContext<AuthStateModel>): void {\n            patchState(AuthDefaultState);\n            dispatch(new Navigate([this.loginUrl]));\n        }\n    }\n\nFor index.ts you just need to export this state and actions\n\n    // src/_store/auth/index.ts\n    export * from './auth.actions.ts';\n    export * from './auth.state.ts';\n\n\n**4. Using NGXS on the Login Component**\n\nOn your login.component.html\n\n    // login.component.html\n    <form role=\"form\" [formGroup]=\"form\" (ngSubmit)=\"form.valid && onSubmit()\">\n\t    <mat-form-field appearance=\"outline\">\n\t        <mat-label>Email</mat-label>\n\t        <input \n\t            matInput \n\t            formControlName=\"email\" \n\t            placeholder=\"Email\"\n\t        />\n\t    </mat-form-field>\n\n\t    <mat-form-field appearance=\"outline\">\n\t        <mat-label>Password</mat-label>\n\t        <input \n\t            matInput\n\t            type=\"password\"\n\t            formControlName=\"password\"\n\t            placeholder=\"Password\"\n\t        />\n\t    </mat-form-field>\n\n\t    <div class=\"block\">\n\t        <button \n\t            mat-raised-button\n\t            type=\"submit\" \n\t            color=\"primary\" \n\t            class=\"w-full\"\n\t        >\n\t            Login\n\t        </button>\n\t    </div>\n    </form>\nThis is a simple form for login. In your login.component.ts \n\n    import { Component, OnDestroy } from '@angular/core;\n    import { FormBuilder, FormGroup, Validators } from '@angular/forms';\n    import { Store } from '@ngxs/store';\n    import { Login } from '../../_store/auth';\n    import { takeUntil } from 'rxjs/operators';\n    import { Subject } from 'rxjs';\n    \n    @Component({\n      selector: 'app-login',\n      templateUrl: './login.component.html'\n    })\n    export class LoginComponent implements  OnDestroy {\n    \n      public form: FormGroup;\n      protected subscription: = new Subject();\n    \n      constructor(\n        private _fb: FormBuilder,\n        private _store: Store\n      ) {\n        this.form = this._fb.group({\n          email: [null, [Validators.required, Validators.email]],\n          password: [null, Validators.required]\n        });\n      }\n    \n      ngOnDestroy(): void {\n        this._subscription.next();\n        this._subscription.complete();\n      }\n    \n      onSubmit(): void {\n        const credentials = this.form.value;\n    \n        this._store\n          .dispatch(new Login(credentials))\n          .pipe(takeUntil(this._subscription))\n          .subscribe(\n            (res: any) => {\n              // Message\n            },\n            (err: any) => {\n              // Error Message\n            }\n          );\n      }\n    }\n\nSo when the user submit the form, it will dispatch Login Action in the Auth State if the response is success it will redirect the user on the set fallback url.\n\n    // src/_store/auth/auth.state.ts\n    protected readonly fallbackUrl = 'dashboard';\n\nOn the next part we will cover the **token interceptor**, **route guard** and **refresh token**."}}]);